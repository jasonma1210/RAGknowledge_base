2. 前端流接收与解码（Fetch + ReadableStream）
前端通过 fetch 请求后端流接口，利用 ReadableStream 监听数据片段，并用 TextDecoder 处理 UTF-8 编码（避免中文乱码）。
核心逻辑：
调用 fetch 时，通过 response.body.getReader() 获取流读取器；
循环调用 reader.read() 接收数据片段（done 为 true 表示流结束）；
用 TextDecoder 将二进制片段解码为字符串，暂存到缓冲区。
3. 打字机效果渲染（定时器逐字符弹出）
将缓冲区的字符串通过 定时器（setInterval/setTimeout）逐字符 / 逐词添加到 DOM，配合 CSS 动画增强视觉效果（如光标闪烁）。
三、完整代码示例（原生 JS + HTML）
html
预览
<!DOCTYPE html>
<html>
<head>
  <title>流式响应 + 打字机效果</title>
  <style>
    /* 打字机容器样式 */
    .typewriter-container {
      width: 600px;
      margin: 20px auto;
      padding: 20px;
      border: 1px solid #eee;
      border-radius: 8px;
      font-size: 16px;
      line-height: 1.5;
    }
    /* 光标闪烁动画 */
    .cursor {
      display: inline-block;
      width: 8px;
      height: 1.2em;
      background: #333;
      margin-left: 2px;
      animation: blink 0.8s infinite alternate;
    }
    @keyframes blink {
      from { opacity: 1; }
      to { opacity: 0; }
    }
  </style>
</head>
<body>
  <div class="typewriter-container">
    <div id="content"></div> <!-- 流式文本渲染容器 -->
    <span class="cursor"></span> <!-- 打字机光标 -->
  </div>

  <script>
    // 1. 初始化 DOM 元素和状态
    const contentEl = document.getElementById('content');
    const cursorEl = document.querySelector('.cursor');
    let textBuffer = ''; // 存储已接收的流文本
    let renderIndex = 0; // 已渲染的字符索引
    let renderTimer = null; // 打字机定时器

    // 2. 处理流式响应的核心函数
    async function handleStreamingResponse() {
      try {
        const response = await fetch('/stream-data', {
          method: 'GET',
          headers: { 'Accept': 'text/plain' }
        });

        // 检查响应是否支持流（排除后端错误、跨域等问题）
        if (!response.ok || !response.body) {
          throw new Error('后端响应异常或不支持流');
        }

        // 3. 初始化流读取器和文本解码器（处理 UTF-8 编码）
        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8'); // 关键：避免中文乱码

        // 4. 循环读取流数据片段
        while (true) {
          const { done, value } = await reader.read();
          if (done) break; // 流结束，退出循环

          // 将二进制片段解码为字符串，追加到缓冲区
          const chunk = decoder.decode(value, { stream: true }); // stream:true 表示后续还有数据
          textBuffer += chunk;

          // 5. 启动/重启打字机渲染（避免重复启动定时器）
          if (!renderTimer) {
            startTypewriter();
          }
        }

        // 流结束后，清除光标（可选）
        clearInterval(renderTimer);
        cursorEl.style.display = 'none';
        console.log('流接收完成');

      } catch (error) {
        contentEl.textContent = `错误：${error.message}`;
        cursorEl.style.display = 'none';
      }
    }

    // 6. 打字机渲染函数（逐字符弹出）
    function startTypewriter() {
      // 定时器：每 80ms 渲染 1 个字符（可调整速度）
      renderTimer = setInterval(() => {
        if (renderIndex < textBuffer.length) {
          // 追加当前字符到 DOM
          contentEl.textContent += textBuffer[renderIndex];
          renderIndex++;
        } else {
          // 缓冲区已渲染完，暂停定时器（等待后续流数据）
          clearInterval(renderTimer);
          renderTimer = null;
        }
      }, 80);
    }

    // 页面加载后启动流请求
    window.onload = handleStreamingResponse;
  </script>
</body>
</html>
四、框架适配（Vue 3 / React）
在框架中实现逻辑类似，核心是将 “流接收” 和 “打字机状态” 绑定到组件的响应式数据，避免 DOM 直接操作。
示例：Vue 3 组件
vue
<template>
  <div class="typewriter-container">
    <div>{{ renderedText }}</div>
    <span class="cursor" v-if="showCursor"></span>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';

const renderedText = ref(''); // 响应式：已渲染的文本
const showCursor = ref(true); // 响应式：光标显示状态
let textBuffer = ''; // 非响应式：暂存已接收的流文本
let renderIndex = 0;
let renderTimer = null;
let reader = null; // 流读取器（用于组件卸载时中断流）

// 流接收逻辑
const fetchStream = async () => {
  try {
    const response = await fetch('/stream-data');
    if (!response.ok || !response.body) throw new Error('流响应异常');

    reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      textBuffer += decoder.decode(value, { stream: true });
      if (!renderTimer) startTypewriter();
    }

    // 流结束
    clearInterval(renderTimer);
    showCursor.value = false;
  } catch (err) {
    renderedText.value = `错误：${err.message}`;
    showCursor.value = false;
  }
};

// 打字机渲染
const startTypewriter = () => {
  renderTimer = setInterval(() => {
    if (renderIndex < textBuffer.length) {
      renderedText.value += textBuffer[renderIndex];
      renderIndex++;
    } else {
      clearInterval(renderTimer);
      renderTimer = null;
    }
  }, 80);
};

// 组件生命周期：挂载时启动流，卸载时清理
onMounted(fetchStream);
onUnmounted(() => {
  if (renderTimer) clearInterval(renderTimer);
  if (reader) reader.cancel(); // 中断未完成的流读取
  showCursor.value = false;
});
</script>

<style scoped>
/* 同原生 HTML 的样式 */
.typewriter-container { ... }
.cursor { ... }
</style>
五、关键优化点
避免中文乱码：必须使用 TextDecoder 解码二进制流（指定 utf-8），因 ReadableStream 返回的 value 是 Uint8Array（二进制），直接转字符串会导致中文乱码。
流中断处理：组件卸载或用户取消请求时，需调用 reader.cancel() 中断流读取，避免内存泄漏（尤其在 React/Vue 中）。
打字机速度控制：可通过动态调整定时器间隔（如 speed = 50 更快，speed = 150 更慢），甚至支持用户手动调节。
大文本分段渲染：若后端返回大段文本（如长文档），可改为 “逐词 / 逐句渲染”（按空格或标点分割），避免单字符渲染导致的性能问题。
错误处理：需捕获 3 类错误：
网络错误（如断网）；
后端响应错误（如 500 状态码）；
流解码错误（如非 UTF-8 编码）。